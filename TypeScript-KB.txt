
    @@@@@@@@@@@@@@@@@@@@@

        TypeScript

    @@@@@@@@@@@@@@@@@@@@@

Check typescript version

  $ tsc -version
  
Compiling:

  $ tsc script.ts




Variables
---------

primary difference between var and let/const is in the scoping rules.

var
    Variables declared with 'var' are globally available in the function in which they are declared.
    Even if a variable is nested levels deep...

    Variables declared with 'var' are hoisted to the top of the function in which they are declared.



let

const    

    variables declared with 'let' and 'const' are only available in the block in which they are declared
    not 'hoisted' to the top of the block/container where they are declared.

    variable can be declared by the same name again in the same function where it is already declared.


Basic Types
-----------

Boolean
Number
String
Array
Tuple
Enum
Any
Void
Null and Undefined
Never


  Boolean
  -------
    e.g.
      let isDone: boolean = false;


  Number
  ------
    floating-point type (just like js)

      function returnNumber(): number {
        return 42;
      }

    Literal Support

      let decimalNumber: number = 6; // decimal literal
      let hexNumber: number = 0xf00d; // hex literal
      let binaryNumber: number = 0b1010; // binary literal
      let octalNumber: number = 0o744; // octal literal


  String
  ------
    TypeScript supports either single (') or double (") quotes.

      let myString: string = 'this is a string';
      let color: string = "red";

    Template strings: 
      - can span multiple lines and have embedded expressions
      - surrounded by backquotes (`)
      - embedded expressions are of the form ${ expr }

        let fullName: string = 'Bob Bobbington';
        let age: number = 37;
        let sentence: string = 
          `Hello, my name is ${fullName}.
          
          I'll be ${ age + 1 } years old next month.`

      This is equivalent to:
terminal
        let sentence: string = "Hello, my name is " + fullName + ".\n\n" +
        "I'll be " + (age + 1) + " years old next month."



  Array  
  -----
    can specify type of the array elements
    Array types can be written in one of two ways:

      1) array type is followed by []

        let list: number[] = [1,2,3];

      2) Array<elementType>
       
        let list: Array<number> = [1,2,3];


  Tuple
  -----

    allow you to epxress an array where the type of a fixed number of elements
    is known, but need not be the same.

      // a pair of a 'string' and a 'number'
      let x: [string, number];
      // initialize x
      x = ['hello', 10]; // OK
      // initialize incorrectly
      x = [10, 'hello']; // Error

    When accessing an elment with a known index, the correct type is retrieved:

      console.log(x[0].substr(1)); // OK
      console.log(x[1].substr(1)); // Error, .. i.e. doesn't exist



  Enum
  ----

    a helpful addition to the standard set of datatypes from JavaScript.
    a way to give friendly names to a set of numeric values.

      enum Color {Red, Green, Blue};
      let c: Color = Color.Green;

    by default numbering starts with '0' but can be changed:

      enum Color { Red = 1, Green, Blue };     

    or

      enum Color { Red = 1,  Green = 2, Blue = 4 };       

  Any
  ----

    any type - we many need to describe a type of variable that do not know
    when we write an application.  These may come from some dynamic content,
    or a 3rd party library.  In these cases, we want to opt out of type 
    checking and let the values pass thru compile time checks.

      let notSure: any = 4;
      notSure = "maybe a string?";
      notSure = false; // okay a boolean

    the 'any' type is a powerful way to work with existing JS.
    You might expect Object to play a similar role, but variables of type 
    Object only allow you to assign any value to them - you can't call 
    arbitrary methods on them:

      let notSure: any = 4;
      notSure.ifItExists(); // ok, ifItExists method might exist at runtime
                            // but the compiler doesn't check

      let prettySure: Object = 4; 
      prettySure.toFixed(); // error: property 'toFixed' doesn't exist


  Void
  ----
    specifies absence of a type.   Function return type.

    declaring values of type 'void' is not useful  because you can only 
    assign 'Undefined' or 'null' to them

  null and Undefined
  -------------------

    both actually have their own types.
    much like void - not useful on their own

    When using the "--strictNullChecks" flag, null and undefined are only 
    assignable to 'void' and their respective types.  This helps avoid many 
    common errors...
    In cases where you want to puass in either a string or null or undefined,
    you can just use the union type:

      string | null | undefined


  Never
  -----

    The never type represents the type of values that never occur.
    e.g. never is a return type for a function expression or an arrow function
    expression that always throws an exception or one that never returns.

    The 'never' type is a subtype of every type.. however, 
    nothing is a subtype of - or assignable to - never, not even 'any'

    examples of functions returning 'never':

      // inferred return type is never
      function fail() {
        return error("Something failed");
      }

      // function returning 'never' must have unreachable end point
      function infiniteLoop(): never {
        while (true) {
         // 
        }
      }


  Type Assertions
  ---------------

    sometimes you'll know more about a value than TypeScript does.
    usually this will happen when you know the type of some entity could be
    more specific than its current type.

    "type assertions" 
      - are a way to tell the compiler "trust me, I know what
      i'm doing"
      - is like a type cast in other languages
      - has no runtime impact
      - purely for the compiler

    there are two forms:
    a) angle bracket syntax:

      let someValue: any = "this is a string";
      let strLength: number = (<string>someValue).length;

    b) 'as' syntax

      let  someValue: any = 'this is a string';
      let strLength: number = (someValue as string).length;



TypeScript Inference
--------------------

TypeScript infers the type based on the assignment.
  let myString = 'this is a string';    
Avoid Inference.


Function types
--------------

Typically in JS, you can assign functions to variables. Any functions.
Here, you can assign sayHello function to myMultiply variable.


  // void
  function sayHello(): void {
    console.log("Hello");
  }

  let myMultiply;
  myMultiply = sayHello;  // no errors..

However, TypeScript allows you to specify function types by describing the
function signature as type:

  // function types
  let myMultiply: (val1: number, val2: number) => number;
  //myMultiply = sayHello;  // won't work .. once function type is defined
  //myMultiply();

However, i can assign 'multiply' function to myMultiply variable because 
it matches the function type:

  // multiply function with argument types
  function multiply(value1: number, value2: number): number {
    return value1 * value2;
  }


  myMultiply = multiply;
  console.log(myMultiply(10,2));


Object Types
-------------

  // objects

  // typescript infers the object type from the declaration
  // property names do matter in the context of objects, order is not important
  let userData = {
    name: "Max",
    age: 27
  };

  // object type declaration
  let userDataRedefined: { name: string, age: number } = {
    name: "Max",
    age: 27
  };

  // complex object
  // this object has two properties - "data" and "output"
  let complex: {data: number[], output: (all: boolean) => number[]} = {
    data: [100, 3.99, 10],
    output: function(all: boolean): number[] {
      return this.data;
    }
  };



==============================================================================


Functions
----------

Functions in TS vs JS

1. TS functions allow you to specify parameter and return types
2. Parameters: you can declare optional or default values
  - optional params
  - default params
  - rest parameters
3. Function overloading

4. Support for Arrow functions


Parameter Types and Return Types

  function CreateCustomerID(name: string, id: number): string {
    return name + id;
  }


Arrow Functions

  lambda functions - a consice way of writing anonymous functions

  let arr = allBooks.filter(function(book) {
    return book.author === 'Herman Melville';
  }); 

  Above example of an anonymous function with traditional syntax.
  Below is the same function written with the arrow syntax:

  let arr = allBooks.filter(book => book.author === 'Herman Melville');

    left of the arrow is param ..  right of the arrow is the function body
    [         book              =>      book.author === '..'              ]

  syntax
  ------
  Here, we're calling "forEach" function on an array.
  "forEach" takes a function as parameter that will execute once for each element of the array.
  If my arraw function does not accept any parameters, I must supply empty 
  parenthesis.

    myBooks.forEach( () => console.log('Done reading!') );

  Here, same as above, except 'title' is a parameter passed to the lambda expression:

    myBooks.forEach( (title) => console.log(title) );

  Note: parenthesis are NOT required for ONE parameter, but are required for multiple:

    myBooks.forEach( (title, idx, arr) => console.log(idx + ' - ' + title) );

  Place multiple lines of function body inside curly braces:

    myBooks.forEach( (title, idx, arr) => {

      console.log(..);
      // more 
      // more

    });


Capturing 'this' in JavaScript
-----------------------------

Problem with 'this' - it often represents two different execution contexts in 
the same block of code.. 

Given this example:

function book() {
  self.publishDate = 2016;
  setInterval( function() {
    console.log(this.publishDate); // can NOT: 'this' refers to something else inside a callback
  }, 1000);
}

==============================================================================

  Modules and Namespaces
  **********************

Export
------

  In TypeScript, as well as ES2015, any file containing a top-level 'import' or
  'export' is considered a module.

  Any declaration 
    variable
    function
    class
    type alias
    interface
  can be exported     


Namespaces
----------

  Provide organization


==============================================================================






