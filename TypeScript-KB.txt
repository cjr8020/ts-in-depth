
    @@@@@@@@@@@@@@@@@@@@@

        TypeScript

    @@@@@@@@@@@@@@@@@@@@@

Check typescript version

  $ tsc -version
  
      


Variables
---------

primary difference between var and let/const is in the scoping rules.

var
    Variables declared with 'var' are globally available in the function in which they are declared.
    Even if a variable is nested levels deep...

    Variables declared with 'var' are hoisted to the top of the function in which they are declared.



let

const    

    variables declared with 'let' and 'const' are only available in the block in which they are declared
    not 'hoisted' to the top of the block/container where they are declared.

    variable can be declared by the same name again in the same function where it is already declared.


Basic Types
-----------

Boolean
Number
String
Array
Tuple
Enum
Any
Void
Null and Undefined
Never


  Boolean
  -------
    e.g.
      let isDone: boolean = false;


  Number
  ------
    floating-point type (just like js)

      function returnNumber(): number {
        return 42;
      }

    Literal Support

      let decimalNumber: number = 6; // decimal literal
      let hexNumber: number = 0xf00d; // hex literal
      let binaryNumber: number = 0b1010; // binary literal
      let octalNumber: number = 0o744; // octal literal


  String
  ------
    TypeScript supports either single (') or double (") quotes.

      let myString: string = 'this is a string';
      let color: string = "red";

    Template strings: 
      - can span multiple lines and have embedded expressions
      - surrounded by backquotes (`)
      - embedded expressions are of the form ${ expr }

        let fullName: string = 'Bob Bobbington';
        let age: number = 37;
        let sentence: string = 
          `Hello, my name is ${fullName}.
          
          I'll be ${ age + 1 } years old next month.`

      This is equivalent to:

        let sentence: string = "Hello, my name is " + fullName + ".\n\n" +
        "I'll be " + (age + 1) + " years old next month."



  Array  
  -----
    can specify type of the array elements
    Array types can be written in one of two ways:

      1) array type is followed by []

        let list: number[] = [1,2,3];

      2) Array<elementType>
       
        let list: Array<number> = [1,2,3];


  Tuple
  -----

    allow you to epxress an array where the type of a fixed number of elements
    is known, but need not be the same.

      // a pair of a 'string' and a 'number'
      let x: [string, number];
      // initialize x
      x = ['hello', 10]; // OK
      // initialize incorrectly
      x = [10, 'hello']; // Error

    When accessing an elment with a known index, the correct type is retrieved:

      console.log(x[0].substr(1)); // OK
      console.log(x[1].substr(1)); // Error, .. i.e. doesn't exist



  Enum
  ----

    a helpful addition to the standard set of datatypes from JavaScript.
    a way to give friendly names to a set of numeric values.

      enum Color {Red, Green, Blue};
      let c: Color = Color.Green;

    by default numbering starts with '0' but can be changed:

      enum Color { Red = 1, Green, Blue };     

    or

      enum Color { Red = 1,  Green = 2, Blue = 4 };       

  Any
    any type
    avoid using this type

  Void
    specifies absence of a type.   Function return type.


TypeScript Inference
--------------------

TypeScript infers the type based on the assignment.
  let myString = 'this is a string';    
Avoid Inference.


Enums
-------

enum Category { Biography, Poetry, Fiction };  // 0, 1, 2
enum Category { Biography = 1, Poetry, Fiction };  // 1, 2, 3
enum Category { Biography = 2, Poetry = 4, Fiction = 6 };  // 2,4,6

Friendly names are placed inside the curly braces.
By default, numbers will be assigned in order.



Arrays
------

Can be declared two different ways:

1. 
  let strArray1: string[] = [ 'here', 'are', 'strings' ];

  let strArray2: Array<string> = [ 'more', 'strings', 'here' ];

  let anyArray: any[] = [42, true];


Tuples
------

special type of array where the first few elements are specified.
these types do not have to be the same

let myTuple: [number, string] = [25, 'truck'];
let firstElement = myTuple[0]; // 25
let secondElement = myTuple[1]; // truck

// additional elements can be any type from those already specified

myTuple[2] = 100;
myTuple[2] = 'this works too';


Functions
----------

Functions in TS vs JS

1. TS functions allow you to specify parameter and return types
2. Parameters: you can declare optional or default values
  - optional params
  - default params
  - rest parameters
3. Function overloading

4. Support for Arrow functions


Parameter Types and Return Types

  function CreateCustomerID(name: string, id: number): string {
    return name + id;
  }

Arrow Functions

  lambda functions - a consice way of writing anonymous functions

  let arr = allBooks.filter(function(book) {
    return book.author === 'Herman Melville';
  }); 

  Above example of an anonymous function with traditional syntax.
  Below is the same function written with the arrow syntax:

  let arr = allBooks.filter(book => book.author === 'Herman Melville');

    left of the arrow is param ..  right of the arrow is the function body
    [         book              =>      book.author === '..'              ]

  syntax
  ------
  Here, we're calling "forEach" function on an array.
  "forEach" takes a function as parameter that will execute once for each element of the array.
  If my arraw function does not accept any parameters, I must supply empty 
  parenthesis.

    myBooks.forEach( () => console.log('Done reading!') );

  Here, same as above, except 'title' is a parameter passed to the lambda expression:

    myBooks.forEach( (title) => console.log(title) );

  Note: parenthesis are NOT required for ONE parameter, but are required for multiple:

    myBooks.forEach( (title, idx, arr) => console.log(idx + ' - ' + title) );

  Place multiple lines of function body inside curly braces:

    myBooks.forEach( (title, idx, arr) => {

      console.log(..);
      // more 
      // more

    });


Capturing 'this' in JavaScript
-----------------------------

Problem with 'this' - it often represents two different execution contexts in 
the same block of code.. 

Given this example:

function book() {
  self.publishDate = 2016;
  setInterval( function() {
    console.log(this.publishDate); // can NOT: 'this' refers to something else inside a callback
  }, 1000);
}










