
    @@@@@@@@@@@@@@@@@@@@@

        TypeScript

    @@@@@@@@@@@@@@@@@@@@@

Check typescript version

  $ tsc -version
  
Compiling:

  $ tsc script.ts




Variables
---------

primary difference between var and let/const is in the scoping rules.

var
    Variables declared with 'var' are globally available in the function in which they are declared.
    Even if a variable is nested levels deep...

    Variables declared with 'var' are hoisted to the top of the function in which they are declared.



let

  unlike 'var' which creates a global scope variable, let creates a block
  scope variable

const    

    variables declared with 'let' and 'const' are only available in the block in which they are declared
    not 'hoisted' to the top of the block/container where they are declared.

    variable can be declared by the same name again in the same function where it is already declared.


Basic Types
-----------

Boolean
Number
String
Array
Tuple
Enum
Any
Void
Null and Undefined
Never


  Boolean
  -------
    e.g.
      let isDone: boolean = false;


  Number
  ------
    floating-point type (just like js)

      function returnNumber(): number {
        return 42;
      }

    Literal Support

      let decimalNumber: number = 6; // decimal literal
      let hexNumber: number = 0xf00d; // hex literal
      let binaryNumber: number = 0b1010; // binary literal
      let octalNumber: number = 0o744; // octal literal


  String
  ------
    TypeScript supports either single (') or double (") quotes.

      let myString: string = 'this is a string';
      let color: string = "red";

    Template strings: 
      - can span multiple lines and have embedded expressions
      - surrounded by backquotes (`)
      - embedded expressions are of the form ${ expr }

        let fullName: string = 'Bob Bobbington';
        let age: number = 37;
        let sentence: string = 
          `Hello, my name is ${fullName}.
          
          I'll be ${ age + 1 } years old next month.`

      This is equivalent to:
terminal
        let sentence: string = "Hello, my name is " + fullName + ".\n\n" +
        "I'll be " + (age + 1) + " years old next month."



  Array  
  -----
    can specify type of the array elements
    Array types can be written in one of two ways:

      1) array type is followed by []

        let list: number[] = [1,2,3];

      2) Array<elementType>
       
        let list: Array<number> = [1,2,3];


  Tuple
  -----

    allow you to epxress an array where the type of a fixed number of elements
    is known, but need not be the same.

      // a pair of a 'string' and a 'number'
      let x: [string, number];
      // initialize x
      x = ['hello', 10]; // OK
      // initialize incorrectly
      x = [10, 'hello']; // Error

    When accessing an elment with a known index, the correct type is retrieved:

      console.log(x[0].substr(1)); // OK
      console.log(x[1].substr(1)); // Error, .. i.e. doesn't exist



  Enum
  ----

    a helpful addition to the standard set of datatypes from JavaScript.
    a way to give friendly names to a set of numeric values.

      enum Color {Red, Green, Blue};
      let c: Color = Color.Green;

    by default numbering starts with '0' but can be changed:

      enum Color { Red = 1, Green, Blue };     

    or

      enum Color { Red = 1,  Green = 2, Blue = 4 };       

  Any
  ----

    any type - we many need to describe a type of variable that do not know
    when we write an application.  These may come from some dynamic content,
    or a 3rd party library.  In these cases, we want to opt out of type 
    checking and let the values pass thru compile time checks.

      let notSure: any = 4;
      notSure = "maybe a string?";
      notSure = false; // okay a boolean

    the 'any' type is a powerful way to work with existing JS.
    You might expect Object to play a similar role, but variables of type 
    Object only allow you to assign any value to them - you can't call 
    arbitrary methods on them:

      let notSure: any = 4;
      notSure.ifItExists(); // ok, ifItExists method might exist at runtime
                            // but the compiler doesn't check

      let prettySure: Object = 4; 
      prettySure.toFixed(); // error: property 'toFixed' doesn't exist


  Void
  ----
    specifies absence of a type.   Function return type.

    declaring values of type 'void' is not useful  because you can only 
    assign 'Undefined' or 'null' to them


  null and Undefined
  -------------------

    both actually have their own types.
    much like void - not useful on their own

    When using the "--strictNullChecks" flag, null and undefined are only 
    assignable to 'void' and their respective types.  This helps avoid many 
    common errors...
    In cases where you want to puass in either a string or null or undefined,
    you can just use the union type:

      string | null | undefined

  Nullable types
  --------------

    // Nullable
    let canBeNull = 12;
    canBeNull = null; // and now its null

    // undefined
    let canAlsoBeNull; // at this point its undefined cause its uninitialized
    canAlsoBeNull = null;



  Non-Nullable types
  ------------------    

    tsconfig.json

    "strictNullChecks": true

      // now its Non-Nullable
      let cannotBeNull = 12;
      cannotBeNull = null; // and now its null    

      Error: type 'null' is not assignable to type 'number'

    If you still want to allow null, use UNION Type

      // still Nullable
      let stillNullable: number | null = 12;
      stillNullable = null; // no problem ..

    With this compiler setting type 'any' is NO LONGER INFERRED!

      // can this be any?
      let canThisBeAny = null; // with strictNullChecks, what type is this?
      canThisBeAny = 12; // error: 'number' is not assignable to type 'null'



  Never
  -----

    The never type represents the type of values that never occur.
    e.g. never is a return type for a function expression or an arrow function
    expression that always throws an exception or one that never returns.

    The 'never' type is a subtype of every type.. however, 
    nothing is a subtype of - or assignable to - never, not even 'any'

    examples of functions returning 'never':

      // inferred return type is never
      function fail() {
        return error("Something failed");
      }

      // function returning 'never' must have unreachable end point
      function infiniteLoop(): never {
        while (true) {
         // 
        }
      }

    Main use: with functions or code that will never be reached

  Type Assertions
  ---------------

    sometimes you'll know more about a value than TypeScript does.
    usually this will happen when you know the type of some entity could be
    more specific than its current type.

    "type assertions" 
      - are a way to tell the compiler "trust me, I know what
      i'm doing"
      - is like a type cast in other languages
      - has no runtime impact
      - purely for the compiler

    there are two forms:
    a) angle bracket syntax:

      let someValue: any = "this is a string";
      let strLength: number = (<string>someValue).length;

    b) 'as' syntax

      let  someValue: any = 'this is a string';
      let strLength: number = (someValue as string).length;



TypeScript Inference
--------------------

TypeScript infers the type based on the assignment.
  let myString = 'this is a string';    
Avoid Inference.


Function types
--------------

Typically in JS, you can assign functions to variables. Any functions.
Here, you can assign sayHello function to myMultiply variable.


  // void
  function sayHello(): void {
    console.log("Hello");
  }

  let myMultiply;
  myMultiply = sayHello;  // no errors..

However, TypeScript allows you to specify function types by describing the
function signature as type:

  // function types
  let myMultiply: (val1: number, val2: number) => number;
  //myMultiply = sayHello;  // won't work .. once function type is defined
  //myMultiply();

However, i can assign 'multiply' function to myMultiply variable because 
it matches the function type:

  // multiply function with argument types
  function multiply(value1: number, value2: number): number {
    return value1 * value2;
  }


  myMultiply = multiply;
  console.log(myMultiply(10,2));


Object Types
-------------

  // objects

  // typescript infers the object type from the declaration
  // property names do matter in the context of objects, order is not important
  let userData = {
    name: "Max",
    age: 27
  };

  // object type declaration
  let userDataRedefined: { name: string, age: number } = {
    name: "Max",
    age: 27
  };

  // complex object
  // this object has two properties - "data" and "output"
  let complex: {data: number[], output: (all: boolean) => number[]} = {
    data: [100, 3.99, 10],
    output: function(all: boolean): number[] {
      return this.data;
    }
  };

Type alias
------------

Type alias allows us to create a Type definition.
(another option for creating a type blueprint is oviously a Class)

  // complex object
  // this object has two properties - "data" and "output"
  let complex: {data: number[], output: (all: boolean) => number[]} = {
    data: [100, 3.99, 10],
    output: function(all: boolean): number[] {
      return this.data;
    }
  };

  // new object - with the same declaration
  let complex2: {data: number[], output: (all: boolean) => number[]} = {
    data: [100, 2.33, 10],
    output: function(all: boolean): number[] {
      return this.data;
    }
  }

  // how do I store the type definition? classes is one option.
  // another option is a Type Alias
  type Complex = {data: number[], output: (all: boolean) => number[]};

Union Types
-----------

let myRealRealAge: number | string = 27;
myRealRealAge = "27"; // also works


Type Checks
-----------

typeof

  let finalValue = "A string";

  if (typeof finalValue == "number") {
    console.log("this is a number");
  }


// Exercise - assign types where they are missing
-------------------------------------------------

  type BankAccount = {money: number, deposit: (value: number) => void};
  let bankAccount: BankAccount = {
    money: 2000,
    deposit: function (value: number): void {
      this.money += value;
    }
  };

  let myself: {name: string, bankAccount: BankAccount, hobbies: string[]} = {
    name: "Max",
    bankAccount: bankAccount,
    hobbies: ["Sports", "Cooking"]
  };

  myself.bankAccount.deposit(300);
  console.log(myself);


==============================================================================


Functions
----------

  just as in JS, TS functions can be created both as a named function or as
  an anonymous function.

    // named
    function add(x,y) {
      return x+y;
    }

    // named with types
    function add(x: number, y: number): number { ... }


    // anonymous
    let myAdd = function(x,y) { return x+y; };
    // anonymous with type
    let myAdd = function(x: number, y: number): number { ... }

  just as in JS, functions can refer to variables outside of the function body.
  when they do so, they're said to CAPTURE these variables. 

  function types:

    let myAdd = 
       function(x, y): number { return x+y; };

    let myAdd: (x: number, y: number)=>number =         
       function(x: number, y: number): number { return x+y; };
or
    let myAdd: (baseValue: number, increment: number)=>number =         
       function(x: number, y: number): number { return x+y; };



Functions in TS vs JS

1. TS functions allow you to specify parameter and return types
2. Parameters: you can declare optional or default values
  - optional params
  - default params
  - rest parameters
3. Function overloading

4. Support for Arrow functions

In TS, every parameter is assumed to be required.  A parameter can be given a 
null or undefined if desired.  However, the compiler will check that the user
has provided a value for each parameter.

in JS, every param is optional, and users may leave them off as they see fit.
When they do, the value is undefined.
In TS, we can add a (?) to the end of the parameter to make it optional.

  function buildName(firstName: string, lastName?: string) {
    if (lastName) { return firstName + " " + lastName; }
    else return firstName;
  }

Any OPTIONAL parameters must FOLLOW required parameters.
DEFAULT values:

  function buildName(firstName: string, lastName = "Smith") { ... }

  let result1 = buildName("Bob"); // result is "Bob Smith"
  let result2 = buildName("Bob", undefined); // same ...
  let result3 = buildName("Bob", "Adams"); // result is "Bob Adams"



Spread Operator
---------------
  (...)
  turns iterable values into arguments, 
  e.g. turns an array into a list an argument list:

    > Math.max(-1, 5, 11, 3)
    or
    > Math.max(...[-1, 5, 11, 3]); 


Rest (of the) Parameters
------------------------
  without rest parameters, passing an unknown list of arguments is cumbersome:

    function makeArray(arg1: number, arg2: number) {
      return [arg1, arg2];
    }
    console.log(makeArray(1, 2));  


  Rest parameters are treated as a boundless number of optional parameters.

    function makeArray(...args: number[]) {
      return args;
    }
    console.log(makeArray(1, 2, 6, 7));


  The ellipses (...) is also used in the type of the function with rest params:

    let buildNameCopy: (fname: string, ...rest: string[]) => string = buildName;




Default Parameters
------------------

  const countdown = (start: number = 10): void => {
    while (start > 0) {
      start--;
    };
    console.log("Done!");
  };

  countdown(10);
  countdown();

  with default parameters, this function can now be called without any 
  parameters.


Destructuring Arrays and Objects
----------------------

  for-of loop 
  -----------

    The for-of loop supports destructuring:

      const map = new Map().set(false, 'no').set(true, 'yes');
      for (const [key, value] of map) {
        console.log(key + ' is ' + value);
      }  


Template literals
-----------------

  ES6 has two new kinds of literals:

    template literals

      - multi-line string literals that support interpolation

        const firstName = 'Jane';
        console.log(`Hello ${firstName}!
        How are you
        today?`);

        // Output:
        // Hello Jane!
        // How are you
        // today?        

    tagged template literals

      Tagged template literals (short: tagged templates) are created by mentioning a function before a template literal:

        > String.raw`A \tagged\ template`
        'A \\tagged\\ template'

      Here, the method String.raw is called to produce the result of the 
      tagged template.


this
---------------------------------

  understanding JS function invokation and 'this'
  http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/
  (see section at the bottom of this page).

In JS, 'this' is a variable that gets set when a function is called.
This is a powerful and flexible feature, but it comes at a cost of always
having to know about the context in which the function is executing.

Example:

    let deck = {
        suits: ["hearts", "spades", "clubs", "diamonds"],
        cards: Array(52),
        createCardPicker: function() {
            return function() {
              // . . .
              return {suit: this.suits[pickedSuit], card: pickedCard % 13};
            }
        }
    }

    let cardPicker = deck.createCardPicker();
    let pickedCard = cardPicker();  

    alert("card: " + pickedCard.card + " of " + pickedCard.suit);

If we run this example - we get an error.
This is because the 'this' being used in the function created by 
createCardPicker() method will be set to WINDOW instead of the "deck" object.

That's because we call cardPicker() "on its own" - a top-level non-class-method 
syntax call will use "window" for "this".  (or undefined in strict mode).

We can FIX this problem by making sure the function is bound to the correct 'this'
before we return it to be used later.

  ES6 Arrow functions capture the 'this' where the function is created
  ***************************************

TO DO THIS - we use ES6 arrow syntax --> arrow functions capture the 'this' 
where the function is created rather than where it is invoked:


        createCardPicker: function() {
            return () => {
              // . . .
              return {suit: this.suits[pickedSuit], card: pickedCard % 13};
            }
        }

--noImplicitThis flag
-------------------------

TypeScript will warn you when you make this mistake if you pass 
the "--noImplicitThis" flag to the compiler.

However, as it stands, you will still get an error because 
"this.suits[pickedSuit]" is of type "any".
That's because "this" comes from the function expression inside the object
literal: 
  suits: ["hearts", "spades", "clubs", "diamonds"],

To fix this, provide an explicit "this" parameter...


'this' Parameter
-----------------------
Purpose: ensure that a function is always called on the expected object.

  --noImplicitThis is not going to throw errors.

'this' parameter is a fake parameter that comes first in the parameter list 
of a function:

    function f(this: void) {
      // make sure that 'this' is unusable in this standalone function
    }

To fix the example above, add a couple of interfaces to make types clearer:

    interface Card {
      suit: string;
      card: number;
    }

    interface Deck {
      suits: string[];
      cards: number[];
      createCardPicker(this: Deck): () => Card; 
    }

    let deck: Deck = {

      suits: ["hearts", "spades", "clubs", "diamonds"],
      cards: Array(52);
      // NOTE: the arrow function now explicitly specifies that 
      // its callee must be of type Deck
      createCardPicker: function(this: Deck) {
        return () => {
          // ...
          return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
      }
    }





Arrow Functions
----------------

  fat arrow .. aka lambda function

    const gree = () => {
      console.log("Hello");
    };

  Motivation: 
    - keyword 'function' is not required
    - lexically captures the meaning of 'this'
    - lexically captures the meaning of 'arguments'

syntax
------

  to specify parameters:

    () => { ... }; // no parameters
     x => { ... }; // one parameter, an identifier
(x, y) => { ... }; // several parameters

  to specify a body:

    x => { return x * x };  // block
    x => x * x;             // expression, equivalent to line above.



Arrow functions essentially bind(this)      

    let incrFunction = (x) => x + 1;
    console.log('increment 2: ' + incrFunction(2));

  Arrow functions capture the meaning of 'this' from the surrounding context.

    let incrFunction = (x) => x + 1;
    console.log('increment 2: ' + incrFunction(2));

    function Person(age) {
      console.log("'this' typeof: " + typeof this);
      this.age = age;
      this.growOld = function() {
        this.age++;
      }
    }


    let person: any  = new Person(1);
    setTimeout(person.growOld, 1000);

    setTimeout(
      function() {
        console.log(person.age); // 1, but should have been 2
      },
      2000
    ); 
           
  In above example, person.age is not incremented because 'this' in 
  this.age refers to "Window" object because it is "Window" is what is executing
  the growOld() function.

  We can fix this with using an arrwo function:

      ...
      this.growOld = () => {
         this.age++;
      } 
      ...

  The reason this works is because the reference to 'this' is captured by the
  arrow function from outside the function body  ... 

Learn about ES6 arrow functions
---------------------------
MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
https://www.sitepoint.com/es6-arrow-functions-new-fat-concise-syntax-javascript/
http://exploringjs.com/es6/ch_arrow-functions.html



  syntax
  ------
  Here, we're calling "forEach" function on an array.
  "forEach" takes a function as parameter that will execute once for each element of the array.
  If my arraw function does not accept any parameters, I must supply empty 
  parenthesis.

    myBooks.forEach( () => console.log('Done reading!') );

  Here, same as above, except 'title' is a parameter passed to the lambda expression:

    myBooks.forEach( (title) => console.log(title) );

  Note: parenthesis are NOT required for ONE parameter, but are required for multiple:

    myBooks.forEach( (title, idx, arr) => console.log(idx + ' - ' + title) );

  Place multiple lines of function body inside curly braces:

    myBooks.forEach( (title, idx, arr) => {

      console.log(..);
      // more 
      // more

    });


Capturing 'this' in JavaScript
-----------------------------

Problem with 'this' - it often represents two different execution contexts in 
the same block of code.. 

Given this example:

function book() {
  self.publishDate = 2016;
  setInterval( function() {
    console.log(this.publishDate); // can NOT: 'this' refers to something else inside a callback
  }, 1000);
}

==============================================================================

  Modules and Namespaces
  **********************

Export
------

  In TypeScript, as well as ES2015, any file containing a top-level 'import' or
  'export' is considered a module.

  Any declaration 
    variable
    function
    class
    type alias
    interface
  can be exported     


Namespaces
----------

  Provide organization


==============================================================================

  TypeScript compiler
  *******************

tsconfig.js - TS compiler options

  noEmitOnError (default: false)  - do not compile with errors
  sourceMap (default: false)      - compile TS source map from which JS is generated
                                    one advantage is you can place debug points
                                    in the source map using Chrome Dev Tools 

  noImplicitAny                   - enables checks on explicitely setting type

  noImplicitThis

  strictNullChecks

  noUnusedParameters              - all function parameters should be used



{
    "compilerOptions": {
        "module": "commonjs",
        "target": "es5",
        "noImplicitAny": false,
        "noImplicitThis": false,
        "sourceMap": false,
        "noEmitOnError": true,
        "strictNullChecks": true,
        "noUnusedParameters": true
    },
    "exclude": [
      "node_modules"
    ]
}  




==============================================================================

  JS function invocation and 'this'
  *********************************
http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/

The core primitive - a Function's call() method
------------------
  here is what it does:

  1. make an argList out of params 1 thru end
  2. the first param is 'thisValue'
  3. invoke the function with 'this' set to 'thisValue' and 'argList'

    function hello(thing) {
      console.log(this + " says hello " + thing);
    }
    hello.call("Yehuda", "world"); // outputs "Yehuda says hello world"

Obviously, invoking functions with call() all the time would be pretty annoying.
JS allows us to invoke functions directly using the parens syntax:

  function hello(thing) {
    console.log("Hello " + thing);
  }
  hello("World");
  // which is really:
  hello.call(window, "World");

This behaviour changed in ECMAScript 5 ONLY when using STRICT mode:

  // with ES5 "use strict"
  hello.call(undefined, "world");  

In other words:

  fn(...args)  <==>  fn.call(window [ES5-strict: undefined], ...args)

                     function being called should change its 'thisValue'
                     to the global object when not in strict mode.


Member Functions
----------------

  var person = {
    name: "Brendan Eich",
    hello: function(thing) {
      console.log(this + " says hello " + thing);
    }
  }
  person.hello("world");

// same as

  person.hello.call(person, "world"); 

// And if we attach 'hello' method dynamically .. 

  function hello(thing) {
    console.log(this + " say hello " + thing);
  }
  person = { name: "Brendan Eich" }
  person.hello = hello;
  person.hello("world"); // still same as person.hello.call(person, "world")

  // but calling the standalone function (in non-strict mode)
  
  hello("world"); // "[object DOMWindow]world"

NOTE: the function doesn't have a PERSISTENT notion of its 'this'  -- it is 
always set at call time based upon the way it was invoked by the caller.


Using Function.prototype.bind
------------------------------

sometimes it can be convenient to have a reference to a function with a
PERSISTENT 'this' value -- so people have used a simple closure trick to convert
a function into one with an unchanging 'this':

  var person = {
    name: "Brendan Eich",
    hello: function(thing) {
      console.log(this.name + " says hello " + thing);
    }
  }

  var boundHello = function(thing) { 
    return person.hello.call(person, thing);
  }
    
General purpose trick - ES5 introduced new method: bind() on all Function objects

  var person = {
    name: "Brendan Eich",
    hello: function(thing) {
      console.log(this.name + " says hello " + thing);
    }
  }

  var boundHello = person.hello.bind(person);
  boundHello("world");


==============================================================================






