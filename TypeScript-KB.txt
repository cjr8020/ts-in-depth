
    @@@@@@@@@@@@@@@@@@@@@

        TypeScript

    @@@@@@@@@@@@@@@@@@@@@

Check typescript version

  $ tsc -version
  
      


Variables
---------

primary difference between var and let/const is in the scoping rules.

var
    Variables declared with 'var' are globally available in the function in which they are declared.
    Even if a variable is nested levels deep...

    Variables declared with 'var' are hoisted to the top of the function in which they are declared.



let

const    

    variables declared with 'let' and 'const' are only available in the block in which they are declared
    not 'hoisted' to the top of the block/container where they are declared.

    variable can be declared by the same name again in the same function where it is already declared.


Basic Types
-----------

  Boolean

  Number
    floating-point type (just like js)

    function returnNumber(): number {
      return 42;
    }


  String

    let myString: string = 'this is a string';

  Array  
    can specify type of the array elements

  Enum


  Any
    any type
    avoid using this type

  Void
    specifies absence of a type.   Function return type.


TypeScript Inference
--------------------

TypeScript infers the type based on the assignment.
  let myString = 'this is a string';    
Avoid Inference.


Enums
-------

enum Category { Biography, Poetry, Fiction };  // 0, 1, 2
enum Category { Biography = 1, Poetry, Fiction };  // 1, 2, 3
enum Category { Biography = 2, Poetry = 4, Fiction = 6 };  // 2,4,6

Friendly names are placed inside the curly braces.
By default, numbers will be assigned in order.



Arrays
------

Can be declared two different ways:

1. 
  let strArray1: string[] = [ 'here', 'are', 'strings' ];

  let strArray2: Array<string> = [ 'more', 'strings', 'here' ];

  let anyArray: any[] = [42, true];


Tuples
------

special type of array where the first few elements are specified.
these types do not have to be the same

let myTuple: [number, string] = [25, 'truck'];
let firstElement = myTuple[0]; // 25
let secondElement = myTuple[1]; // truck

// additional elements can be any type from those already specified

myTuple[2] = 100;
myTuple[2] = 'this works too';


Functions
----------

Functions in TS vs JS

1. TS functions allow you to specify parameter and return types
2. Parameters: you can declare optional or default values
  - optional params
  - default params
  - rest parameters
3. Function overloading

4. Support for Arrow functions


Parameter Types and Return Types

  function CreateCustomerID(name: string, id: number): string {
    return name + id;
  }

Arrow Functions

  lambda functions - a consice way of writing anonymous functions

  let arr = allBooks.filter(function(book) {
    return book.author === 'Herman Melville';
  }); 

  Above example of an anonymous function with traditional syntax.
  Below is the same function written with the arrow syntax:

  let arr = allBooks.filter(book => book.author === 'Herman Melville');

    left of the arrow is param ..  right of the arrow is the function body
    [         book              =>      book.author === '..'              ]

  syntax
  ------
  Here, we're calling "forEach" function on an array.
  "forEach" takes a function as parameter that will execute once for each element of the array.
  If my arraw function does not accept any parameters, I must supply empty 
  parenthesis.

    myBooks.forEach( () => console.log('Done reading!') );

  Here, same as above, except 'title' is a parameter passed to the lambda expression:

    myBooks.forEach( (title) => console.log(title) );

  Note: parenthesis are NOT required for ONE parameter, but are required for multiple:

    myBooks.forEach( (title, idx, arr) => console.log(idx + ' - ' + title) );

  Place multiple lines of function body inside curly braces:

    myBooks.forEach( (title, idx, arr) => {

      console.log(..);
      // more 
      // more

    });


Capturing 'this' in JavaScript
-----------------------------

Problem with 'this' - it often represents two different execution contexts in 
the same block of code.. 

Given this example:

function book() {
  self.publishDate = 2016;
  setInterval( function() {
    console.log(this.publishDate); // can NOT: 'this' refers to something else inside a callback
  }, 1000);
}










